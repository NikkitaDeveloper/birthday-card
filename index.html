<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>ChatSharp Mini (single-file)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;background:#0f1724;color:#e6eef8;margin:0;padding:20px}
  h1{margin:0 0 12px}
  textarea{width:100%;height:220px;background:#071122;color:#e6eef8;border:1px solid #223;border-radius:6px;padding:10px;font-family:monospace}
  #console{white-space:pre-wrap;background:#061018;color:#cfe9ff;padding:12px;border-radius:6px;height:220px;overflow:auto;border:1px solid #123;margin-top:10px}
  .row{display:flex;gap:8px;margin-top:8px}
  button{background:#0ea5a4;border:none;color:#002; padding:8px 12px;border-radius:6px;cursor:pointer}
  small{color:#9fb}
</style>
</head>
<body>
  <h1>ChatSharp Mini — single-file</h1>
  <small>Interpreter in JS, synonyms mapping, REPL — static frontend</small>

  <textarea id="editor" spellcheck="false">// Try:
let count = 1
while true
  print count
  let count = count + 1
  if count > 100
    break
  end
end
</textarea>

  <div class="row">
    <button id="run">Run</button>
    <button id="clear">Clear Console</button>
    <button id="stop">Stop</button>
    <label style="margin-left:auto"><input id="debug" type="checkbox" /> Debug</label>
  </div>

  <div id="console"></div>

<script>
/*
  Tiny ChatSharp-like interpreter (JS). This is minimal but workable:
  - tokenizer with synonyms normalization
  - simple parser (line-by-line blocks with 'end' support)
  - evaluator supports: let/assignment, print, if/else, while, for range, def/return simple, break/continue
  - session in-memory (in browser)
  Expand synonyms.json by editing synonymsMap below.
*/

// --- SYNONYMS (map many aliases to 9 core keywords) ---
const synonymsMap = {
  // a few examples; expand as you like
  "function":"def","fn":"def","proc":"def",
  "var":"let","let":"let",
  "for":"loop","foreach":"loop","repeat":"loop",
  "print":"print","echo":"print",
  "while":"while",
  "if":"if","else":"else",
  "break":"break","continue":"continue",
  // mapping sample alternate tokens to canonical tokens
};

// --- UTIL ---
const $ = id => document.getElementById(id);
const out = (s)=>{ $('console').textContent += s + '\n'; $('console').scrollTop = $('console').scrollHeight; }

// --- SIMPLE TOKENIZER (line-based, normalize synonyms) ---
function tokenizeLines(code){
  const lines = code.replace(/\r/g,'').split('\n');
  return lines.map(l => {
    const raw = l.replace(/\t/g,'  ');
    const stripped = raw.trim();
    // normalize leading indentation (not used deeply here)
    const first = stripped.split(/\s+/)[0] || '';
    const normFirst = synonymsMap[first] || first;
    const replaced = stripped.replace(new RegExp('^'+first), normFirst);
    return { raw, line: stripped, norm: replaced };
  });
}

// --- BASIC PARSER / BLOCK COLLECTOR: groups by explicit 'end' or simple indentation ---
// We'll interpret blocks by collecting lines until matching 'end' when a block starter is found.
function collectBlocks(tokenLines){
  // return an array of top-level statements as objects {type,line,body...}
  return tokenLines; // minimal: we will handle in evaluator by checking startsWith
}

// --- EVALUATOR: very small - supports let, assignment, print, if, while, def/return, break/continue, for range ---
function makeRuntime(debug=false){
  const globals = { };
  const funcs = {};
  let running = true;

  function evalExpr(expr){
    expr = expr.trim();
    if(expr==="true") return true;
    if(expr==="false") return false;
    if(expr==="null") return null;
    if(/^["'].*["']$/.test(expr)) return expr.slice(1,-1);
    if(/^[0-9]+$/.test(expr)) return parseInt(expr,10);
    if(/^[0-9]*\.[0-9]+$/.test(expr)) return parseFloat(expr);
    // variable
    if(expr in globals) return globals[expr];
    // simple math - replace var names with values
    try {
      let safe = expr;
      Object.keys(globals).sort((a,b)=>b.length-a.length).forEach(k=>{
        const v = globals[k];
        const rv = (typeof v === 'string')?JSON.stringify(v):String(v);
        safe = safe.replace(new RegExp('\\b'+k+'\\b','g'), rv);
      });
      // allow +,-,*,/,%,(), comparisons
      // eslint-disable-next-line no-eval
      return eval(safe);
    } catch(e){
      if(debug) out('Eval error: '+e.message);
      return expr;
    }
  }

  // execute block of lines starting at index i (mutates index through return)
  function execBlock(lines, i, localVars){
    localVars = localVars || {};
    for(let idx=i; idx<lines.length; ){
      if(!running) return { next: lines.length };
      const obj = lines[idx];
      const line = obj.norm;
      if(line==='' || line.startsWith('//') || line.startsWith('#')) { idx++; continue; }
      if(line.startsWith('print ')){
        const expr = line.slice(6).trim();
        out(String(evalExpr(expr)));
        idx++; continue;
      }
      if(line.startsWith('let ')){
        const rest = line.slice(4);
        const [name, val] = rest.split('=',2).map(s=>s && s.trim());
        globals[name] = evalExpr(val || 'null');
        idx++; continue;
      }
      // plain assignment if contains =
      if(line.includes('=') && !line.startsWith('if ') && !line.startsWith('def ')){
        const [lhs, rhs] = line.split('=',2).map(s=>s.trim());
        globals[lhs] = evalExpr(rhs);
        idx++; continue;
      }
      if(line.startsWith('if ')){
        // find matching else/end
        const cond = line.slice(3).trim();
        const start = idx+1;
        // collect true block until 'else' or 'end'
        let j = start; let foundElse=-1, foundEnd=-1;
        while(j<lines.length){
          if(lines[j].norm === 'end'){ foundEnd = j; break; }
          if(lines[j].norm === 'else'){ foundElse = j; break; }
          j++;
        }
        const condVal = !!evalExpr(cond);
        if(condVal){
          // execute lines between start..(foundElse||foundEnd)-1
          const endIndex = (foundElse!==-1)?foundElse:foundEnd;
          execBlock(lines, start, localVars);
        } else {
          if(foundElse!==-1){
            execBlock(lines, foundElse+1, localVars);
          }
        }
        // jump to after end
        idx = (foundEnd!==-1)?(foundEnd+1):(j+1); continue;
      }
      if(line.startsWith('while ')){
        const cond = line.slice(6).trim();
        // body starts at idx+1 until matching end
        let j=idx+1; let foundEnd=-1;
        while(j<lines.length){
          if(lines[j].norm === 'end'){ foundEnd=j; break; }
          j++;
        }
        if(foundEnd===-1){ out('Error: missing end for while'); return { next: lines.length }; }
        // loop
        while(evalExpr(cond) && running){
          execBlock(lines, idx+1, localVars);
        }
        idx = foundEnd+1; continue;
      }
      if(line.startsWith('def ')){
        // def name params...
        const rest = line.slice(4).trim();
        const [name, params] = rest.split(/\s+/,2);
        // collect body
        let j=idx+1, foundEnd=-1;
        while(j<lines.length){
          if(lines[j].norm === 'end'){ foundEnd=j; break; }
          j++;
        }
        funcs[name] = { params: (params?params.split(',').map(s=>s.trim()):[]), body: lines.slice(idx+1,foundEnd) };
        idx = foundEnd+1; continue;
      }
      // function call: name arg1, arg2  OR name(arg1, arg2)
      {
        const callm = line.match(/^([A-Za-z_][A-Za-z0-9_]*)\s*(.*)$/);
        if(callm){
          const nm = callm[1], rest = callm[2].trim();
          if(nm in funcs){
            // parse args
            let args = [];
            if(rest.startsWith('(') && rest.endsWith(')')){
              args = rest.slice(1,-1).split(',').map(s=>s.trim()).filter(s=>s!=='').map(evalExpr);
            } else if(rest){
              args = rest.split(',').map(s=>s.trim()).filter(s=>s!=='').map(evalExpr);
            }
            // call simple: create locals as copies in globals with param names prefix
            const fn = funcs[nm];
            const saved = {};
            fn.params.forEach((p,i)=>{ saved[p]=globals[p]; globals[p]=args[i]; });
            execBlock(fn.body, 0, {});
            // restore
            fn.params.forEach(p=>{ globals[p]=saved[p]; });
            idx++; continue;
          }
        }
      }
      // if nothing matched
      idx++; 
    }
    return { next: lines.length };
  }

  return {
    run: (code) => {
      running = true;
      const tokenLines = tokenizeLines(code);
      const blocks = collectBlocks(tokenLines);
      execBlock(blocks, 0, {});
    },
    stop: ()=>{ running=false; out('Execution stopped'); },
    globals, funcs
  };
}

// --- UI wiring ---
let runtime = makeRuntime(false);
$('run').addEventListener('click', ()=>{
  $('console').textContent = '';
  runtime = makeRuntime($('debug').checked);
  try { runtime.run($('editor').value); } catch(e){ out('Runtime error: '+e); }
});
$('clear').addEventListener('click', ()=>$('console').textContent='');
$('stop').addEventListener('click', ()=>runtime.stop());

</script>
</body>
</html>