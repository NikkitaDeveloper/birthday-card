<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Personal Data Chat — One File Prototype</title>
<link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&family=Lora:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#071029; --bg2:#0f172a; --card:#f8f1e9; --accent:#1e3a8a;
  }
  html,body{height:100%;margin:0;font-family: Lora, serif;background:linear-gradient(135deg,var(--bg1),var(--bg2));color:#111}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:30px;box-sizing:border-box}
  .book{
    width:1100px;max-width:98vw;background:transparent;display:flex;gap:24px;align-items:stretch;
    perspective:1500px;
  }

  /* Left: The book-like documentary panel (mostly decorative) */
  .doc {
    flex: 0 0 580px;
    background: linear-gradient(135deg,#8B4513,#5D2906);
    border-radius:14px;
    color:var(--card);
    padding:30px;
    box-shadow: 0 30px 60px rgba(0,0,0,0.6);
    transform: translateZ(20px);
    min-height:600px;
    display:flex;flex-direction:column;gap:18px;
  }
  .doc h1{font-family:Merriweather,serif;margin:0;font-size:28px}
  .doc p{opacity:0.95}
  .open-controls{margin-top:auto;display:flex;gap:10px;flex-wrap:wrap}
  .btn{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600}
  .btn.light{background:var(--card);color:#5D2906}
  .btn.accent{background:var(--accent);color:#fff}
  .small{font-size:13px;opacity:0.95}

  /* Right: Chat + training controls */
  .panel{
    flex:1;min-width:360px;background:rgba(248,241,233,0.98);border-radius:12px;padding:18px;box-shadow:0 20px 40px rgba(0,0,0,0.45);
    display:flex;flex-direction:column;
  }
  .panel h2{margin:0 0 6px 0;color:var(--accent);font-family:Merriweather}
  .controls{display:flex;gap:8px;align-items:center;margin-bottom:10px;flex-wrap:wrap}
  textarea#dataInput{width:100%;height:110px;border-radius:8px;padding:10px;border:1px solid #ddd;resize:vertical;font-family:inherit}
  .row{display:flex;gap:8px}
  .file{display:flex;align-items:center;gap:8px}
  .msg-area{flex:1;display:flex;flex-direction:column;gap:8px;margin-top:10px}
  .chat-log{height:320px;overflow:auto;padding:12px;border-radius:8px;border:1px solid #eee;background:white}
  .chat-line{margin-bottom:10px}
  .user{color:#0f172a;font-weight:700}
  .bot{color:#0b3b67}
  .meta{font-size:12px;color:#666;margin-top:4px}
  .input-row{display:flex;gap:8px;margin-top:8px}
  input#q{flex:1;padding:10px;border-radius:8px;border:1px solid #ddd}
  .spinner{display:inline-block;width:16px;height:16px;border:3px solid #ccc;border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}

  /* source hits */
  .hits{margin-top:10px;border-top:1px dashed #ddd;padding-top:10px}
  .hit{background:#fff;border-radius:6px;padding:8px;margin-bottom:8px;border:1px solid #f0f0f0}
  .hint{font-size:13px;color:#444}
  footer{margin-top:14px;font-size:12px;color:#222;opacity:0.8}
  .small-muted{font-size:12px;color:#444}
</style>
</head>
<body>
<div class="wrap">
  <div class="book">

    <!-- Left decorative/document panel -->
    <div class="doc" id="docPanel">
      <h1>Personal Data Chat — Local Prototype</h1>
      <p class="small-muted">Drop notes, essays, chat logs or paste text on the right, click <strong>Train</strong>, then ask questions. Everything runs locally in your browser.</p>

      <div style="background:rgba(255,255,255,0.06);padding:12px;border-radius:8px">
        <p><strong>How it works (simple):</strong></p>
        <ul style="margin-left:18px">
          <li>Chunks text into small paragraphs</li>
          <li>Builds TF-IDF vectors for each chunk inside your browser</li>
          <li>For a question, finds best matching chunks & crafts a short reply</li>
        </ul>
      </div>

      <div class="open-controls">
        <button class="btn light" id="sampleLoad">Load Example Doc</button>
        <button class="btn accent" id="clearAll">Clear Index</button>
        <div style="flex:1"></div>
        <div style="text-align:right" class="small">Local • No servers • Privacy first</div>
      </div>

    </div>

    <!-- Right interactive panel -->
    <div class="panel">
      <h2>Train & Chat</h2>

      <div class="controls">
        <div style="flex:1">
          <label class="small-muted">Paste text to train (or upload .txt below)</label>
          <textarea id="dataInput" placeholder="Paste paragraphs, notes, chat history..."></textarea>
        </div>
        <div style="width:160px;display:flex;flex-direction:column;gap:8px">
          <button class="btn accent" id="trainBtn">Train</button>
          <button class="btn light" id="addDocBtn">Teach as New Doc</button>
          <label class="small-muted" style="margin-top:6px">Upload <input id="fileInput" type="file" accept=".txt" style="display:inline-block"/></label>
        </div>
      </div>

      <div class="msg-area">
        <div style="display:flex;align-items:center;gap:10px">
          <div class="small-muted">Index: <span id="docCount">0</span> docs • <span id="chunkCount">0</span> chunks</div>
          <div style="flex:1"></div>
          <button class="btn light" id="showIndex">Show Top Chunks</button>
        </div>

        <div class="chat-log" id="chatLog" aria-live="polite"></div>

        <div class="input-row">
          <input id="q" placeholder="Ask a question after training (e.g., 'What happened on Apr 3?')" />
          <button class="btn accent" id="askBtn">Ask</button>
          <button class="btn light" id="askExplain">Ask + Explain</button>
        </div>

        <div id="hits" class="hits" style="display:none"></div>

        <footer>
          Tip: you can press <strong>Teach as New Doc</strong> to keep the pasted text as a separate file (useful for versioned notes).
        </footer>
      </div>
    </div>

  </div>
</div>

<script>
/* ---------- Tiny TF-IDF engine in-browser ----------
   - Works with small documents (notes, chat logs).
   - Tokenizes, removes basic stopwords, builds TF, IDF, then cosine similarity.
   - Pure JS, no external libs.
*/

// Basic stopword list (short)
const STOP = new Set(("a an the and or but if then else when where how is are was were be been by to of in on for with as at from that this these those it its").split(" "));

function tokenize(text){
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .split(/\s+/)
    .filter(t => t && !STOP.has(t));
}

// Chunk text into paragraphs (max length roughly)
function chunkText(text, maxLen=300){
  const paras = text.split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);
  const chunks = [];
  paras.forEach(p => {
    if(p.length <= maxLen){ chunks.push(p); return; }
    // break long para into sentences (naive)
    const sents = p.replace(/[!?]/g, ".").split(".").map(s=>s.trim()).filter(Boolean);
    let cur = "";
    sents.forEach(s => {
      if((cur + " " + s).length <= maxLen) cur = (cur + " " + s).trim();
      else { if(cur) chunks.push(cur); cur = s; }
    });
    if(cur) chunks.push(cur);
  });
  return chunks;
}

class TinyIndex {
  constructor(){
    this.docs = []; // {name, text}
    this.chunks = []; // actual chunk texts
    this.meta = []; // {docName, chunkIndex}
    this.vocab = new Map(); // term -> index
    this.df = []; // doc frequency per term index
    this.tfmat = []; // array of maps: for each chunk, termIndex -> tf
    this.idf = []; // idf vector
    this.norms = []; // precomputed norms for each chunk vector
    this.trained = false;
  }

  addDocument(name, text){
    const chs = chunkText(text);
    const baseIndex = this.chunks.length;
    chs.forEach((c,i) => {
      this.chunks.push(c);
      this.meta.push({doc:name, idx:i});
    });
    this.docs.push({name, text});
  }

  buildIndex(){
    // build vocab and TF maps
    this.vocab.clear(); this.df = []; this.tfmat = []; this.idf = []; this.norms=[];
    let termId = 0;
    this.chunks.forEach((chunk, chunkIdx) => {
      const tlist = tokenize(chunk);
      const tfmap = new Map();
      tlist.forEach(t => {
        if(!this.vocab.has(t)){
          this.vocab.set(t, termId++);
          this.df.push(0);
        }
        const id = this.vocab.get(t);
        tfmap.set(id, (tfmap.get(id)||0) + 1);
      });
      // update df
      const seen = new Set(tfmap.keys());
      seen.forEach(id => this.df[id] = (this.df[id]||0) + 1);
      this.tfmat.push(tfmap);
    });
    const N = this.chunks.length || 1;
    this.idf = this.df.map(df => Math.log((N + 1) / (df + 1)) + 1); // smooth idf
    // compute norms for chunk vectors
    this.norms = this.tfmat.map(tfmap => {
      let s = 0;
      tfmap.forEach((tf, id) => {
        const v = tf * (this.idf[id]||0);
        s += v*v;
      });
      return Math.sqrt(s) || 1;
    });
    this.trained = true;
  }

  query(q, topK=5){
    if(!this.trained) return [];
    const qtokens = tokenize(q);
    const qmap = new Map();
    qtokens.forEach(t => {
      const id = this.vocab.get(t);
      if(id !== undefined) qmap.set(id, (qmap.get(id)||0) + 1);
    });
    // if no overlap in vocab, return empty
    if(qmap.size === 0) return [];
    // compute q vector and norm
    let qnorm = 0;
    qmap.forEach((tf,id) => {
      const v = tf * (this.idf[id]||0);
      qnorm += v*v;
    });
    qnorm = Math.sqrt(qnorm) || 1;
    // compute cosine similarities
    const scores = [];
    for(let i=0;i<this.tfmat.length;i++){
      let dot = 0;
      const tfmap = this.tfmat[i];
      qmap.forEach((qtf,id) => {
        const tf = tfmap.get(id) || 0;
        if(tf) dot += (qtf * (this.idf[id]||0)) * (tf * (this.idf[id]||0));
      });
      const sim = dot / (qnorm * this.norms[i] || 1);
      scores.push({i,sim});
    }
    scores.sort((a,b)=>b.sim - a.sim);
    const hits = scores.filter(s => s.sim > 0).slice(0, topK);
    // return list of {index,score,text,doc}
    return hits.map(h => ({index:h.i, score:h.sim, text:this.chunks[h.i], doc:this.meta[h.i].doc}));
  }
}

/* ---------- UI wiring ---------- */
const idx = new TinyIndex();
const chatLog = document.getElementById('chatLog');
const qInput = document.getElementById('q');
const trainBtn = document.getElementById('trainBtn');
const addDocBtn = document.getElementById('addDocBtn');
const fileInput = document.getElementById('fileInput');
const dataInput = document.getElementById('dataInput');
const docCount = document.getElementById('docCount');
const chunkCount = document.getElementById('chunkCount');
const hitsDiv = document.getElementById('hits');
const askBtn = document.getElementById('askBtn');
const askExplain = document.getElementById('askExplain');
const sampleLoad = document.getElementById('sampleLoad');
const clearAll = document.getElementById('clearAll');
const showIndex = document.getElementById('showIndex');

function appendChat(who, text, small=false){
  const d = document.createElement('div'); d.className='chat-line';
  const name = document.createElement('div'); name.className = who==='You' ? 'user' : 'bot';
  name.textContent = who + (small ? ' • ' + small : '');
  const t = document.createElement('div'); t.innerHTML = text.replace(/\n/g,'<br>');
  d.appendChild(name); d.appendChild(t);
  chatLog.appendChild(d);
  chatLog.scrollTop = chatLog.scrollHeight;
}

function updateStats(){
  docCount.textContent = idx.docs.length;
  chunkCount.textContent = idx.chunks.length;
}

trainBtn.addEventListener('click', () => {
  const text = dataInput.value.trim();
  if(!text){
    alert('Paste text in the box (or upload files) before pressing Train.');
    return;
  }
  idx.addDocument('pasted_' + (idx.docs.length+1) + '.txt', text);
  idx.buildIndex();
  updateStats();
  appendChat('System', 'Trained on pasted text — indexed ' + idx.chunks.length + ' chunks.');
});

addDocBtn.addEventListener('click', () => {
  const text = dataInput.value.trim();
  if(!text){ alert('Paste text first'); return; }
  const name = prompt('Document name (e.g., notes1.txt)', 'pasted_'+(idx.docs.length+1)+'.txt');
  idx.addDocument(name || ('pasted_'+(idx.docs.length+1)+'.txt'), text);
  idx.buildIndex();
  updateStats();
  appendChat('System', `Added document "${name}". Total chunks: ${idx.chunks.length}`);
});

fileInput.addEventListener('change', (ev) => {
  const files = ev.target.files;
  if(!files || !files.length) return;
  const reader = new FileReader();
  const file = files[0];
  reader.onload = (e) => {
    const content = e.target.result;
    idx.addDocument(file.name, content);
    idx.buildIndex();
    updateStats();
    appendChat('System', `Loaded file "${file.name}" (${content.length} chars).`);
  };
  reader.readAsText(file);
  // reset input so same file can be reselected
  fileInput.value = '';
});

askBtn.addEventListener('click', () => doAsk(false));
askExplain.addEventListener('click', () => doAsk(true));

function doAsk(explain=false){
  const q = qInput.value.trim();
  if(!q){ alert('Type a question first'); return; }
  appendChat('You', q);
  // show thinking
  const spinner = document.createElement('span'); spinner.className = 'spinner';
  appendChat('AI', 'Thinking... '); // placeholder
  // small delay to simulate thinking
  setTimeout(()=>{
    // remove last "Thinking..." line
    chatLog.removeChild(chatLog.lastChild);
    if(!idx.trained){ appendChat('AI', "I don't have any indexed data yet. Paste/upload docs on the right and press Train."); return; }
    const hits = idx.query(q, 6);
    if(hits.length === 0){
      appendChat('AI', "I couldn't find anything matching your question in the indexed texts. Try broader terms or train me with more data.");
      hitsDiv.style.display='none';
      return;
    }
    // build reply: show best hit + short followup
    const best = hits[0];
    const snippet = best.text.length > 500 ? best.text.slice(0,500) + '...' : best.text;
    const reply = `<strong>From:</strong> ${escapeHtml(best.doc)} <br><br> ${escapeHtml(snippet)} <br><br><em>Would you like a shorter summary or more details?</em>`;
    appendChat('AI', reply);
    // if explain, show hits
    if(explain){
      showHits(hits);
    } else {
      hitsDiv.style.display='none';
    }
  }, 350 + Math.random()*350);
}

function showHits(hits){
  hitsDiv.innerHTML = '<strong>Top matches used:</strong>';
  hits.forEach(h=>{
    const el = document.createElement('div'); el.className='hit';
    el.innerHTML = `<div style="font-weight:700">${escapeHtml(h.doc)}</div>
                    <div class="hint">${escapeHtml(h.text.length>300? h.text.slice(0,300)+'...' : h.text)}</div>
                    <div class="meta">score: ${h.score.toFixed(3)}</div>`;
    hitsDiv.appendChild(el);
  });
  hitsDiv.style.display='block';
}

// show top chunks for debugging
showIndex.addEventListener('click', () => {
  if(!idx.trained){ alert('Index is empty. Train first.'); return; }
  const n = Math.min(10, idx.chunks.length);
  let html = `<strong>Top ${n} chunks (preview):</strong><br>`;
  for(let i=0;i<n;i++){
    html += `<div style="margin:8px 0;padding:8px;border:1px solid #eee;border-radius:6px;background:#fff"><strong>${escapeHtml(idx.meta[i].doc)}</strong><div style="margin-top:6px">${escapeHtml(idx.chunks[i].slice(0,200))}${idx.chunks[i].length>200?'…':''}</div></div>`;
  }
  appendChat('System', html);
});

sampleLoad.addEventListener('click', () => {
  const sample = `Mar 29: Avdesh starts affectionate chats.
Apr 3: Jealousy about Balram surfaces.
Apr 7: Threats, control, and manipulation begin.
Jun 14: Yogesh starts chatting, calm energy.
Jun 16: Emotional reels, deep affection.
Jun 18: Yogesh defends Shivani, never blames.

Yogesh is affectionate and respectful. Avdesh showed controlling behavior and threats after intimacy.
Key takeaways: emotional safety vs manipulation.`;
  dataInput.value = sample;
  appendChat('System', 'Loaded example text into the paste box. Press Train to index it.');
});

clearAll.addEventListener('click', () => {
  if(!confirm('Clear all indexed documents and chunks?')) return;
  idx.docs = []; idx.chunks=[]; idx.meta=[]; idx.vocab.clear(); idx.df=[]; idx.tfmat=[]; idx.idf=[]; idx.norms=[];
  idx.trained = false;
  updateStats();
  appendChat('System', 'Cleared index.');
});

function escapeHtml(s){
  return s.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
}

// small helper: allow pressing Enter to Ask
qInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && !e.shiftKey){
    e.preventDefault(); doAsk(false);
  }
});

// initial greeting
appendChat('AI', 'Hello — paste/upload documents on the right and press <strong>Train</strong>. Then ask questions. Everything stays on your device.');
updateStats();

</script>
</body>
</html>